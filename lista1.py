# -*- coding: utf-8 -*-
"""Lista1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f2OJT9Y88VUnMX-q6uTEGr6baAuC8hna
"""

// biblioteka.h
#ifndef BIBLIOTEKA_H
#define BIBLIOTEKA_H

typedef struct {
    int x;
    int y;
} DiofantyczneRozwiazanie;

unsigned long long silnia_iteracyjnie(int n);
unsigned long long silnia_rekurencyjnie(int n);
int nwd_iteracyjnie(int a, int b);
int nwd_rekurencyjnie(int a, int b);
DiofantyczneRozwiazanie diofantyczne_iteracyjnie(int a, int b, int c);
DiofantyczneRozwiazanie diofantyczne_rekurencyjnie(int a, int b, int c);

#endif // BIBLIOTEKA_H

// biblioteka.c
#include "biblioteka.h"

unsigned long long silnia_iteracyjnie(int n) {
    if (n < 0) return 0; // Silnia z liczby ujemnej to 0
    unsigned long long result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

unsigned long long silnia_rekurencyjnie(int n) {
    if (n < 0) return 0; // Silnia z liczby ujemnej to 0
    if (n == 0) return 1; // Silnia z 0 to 1
    return n * silnia_rekurencyjnie(n - 1);
}

int nwd_iteracyjnie(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int nwd_rekurencyjnie(int a, int b) {
    if (b == 0) return a;
    return nwd_rekurencyjnie(b, a % b);
}

DiofantyczneRozwiazanie diofantyczne_iteracyjnie(int a, int b, int c) {
    DiofantyczneRozwiazanie result;
    int d = nwd_iteracyjnie(a, b);
    if (c % d == 0) {
        // Obliczanie jednego z możliwych rozwiązań
        int k = c / d;
        result.x = k * (a / d);
        result.y = k * (b / d);
    } else {
        // Brak rozwiązania dla podanych parametrów
        result.x = 0;
        result.y = 0;
    }
    return result;
}

DiofantyczneRozwiazanie diofantyczne_rekurencyjnie(int a, int b, int c) {
    DiofantyczneRozwiazanie result;
    int d = nwd_rekurencyjnie(a, b);
    if (c % d == 0) {
        // Obliczanie jednego z możliwych rozwiązań
        int k = c / d;
        result.x = k * (a / d);
        result.y = k * (b / d);
    } else {
        // Brak rozwiązania dla podanych parametrów
        result.x = 0;
        result.y = 0;
    }
    return result;
}

-- zadanie_2.adb

package Zadanie_2 is
    type Diofantyczne_Rozwiazanie is record
        X : Integer;
        Y : Integer;
    end record;

    function Silnia_Iteracyjnie(N : Integer) return Integer;
    function Silnia_Rekurencyjnie(N : Integer) return Integer;
    function NWD_Iteracyjnie(A, B : Integer) return Integer;
    function NWD_Rekurencyjnie(A, B : Integer) return Integer;
    function Diofantyczne_Iteracyjnie(A, B, C : Integer) return Diofantyczne_Rozwiazanie;
    function Diofantyczne_Rekurencyjnie(A, B, C : Integer) return Diofantyczne_Rozwiazanie;
end Zadanie_2;

-- zadanie_2.adb

package body Zadanie_2 is
    function Silnia_Iteracyjnie(N : Integer) return Integer is
        Result : Integer := 1;
    begin
        if N < 0 then
            return 0; -- Silnia z liczby ujemnej to 0
        end if;
        for I in 1 .. N loop
            Result := Result * I;
        end loop;
        return Result;
    end Silnia_Iteracyjnie;

    function Silnia_Rekurencyjnie(N : Integer) return Integer is
    begin
        if N < 0 then
            return 0; -- Silnia z liczby ujemnej to 0
        elsif N = 0 then
            return 1; -- Silnia z 0 to 1
        else
            return N * Silnia_Rekurencyjnie(N - 1);
        end if;
    end Silnia_Rekurencyjnie;

    function NWD_Iteracyjnie(A, B : Integer) return Integer is
        Temp : Integer;
    begin
        while B /= 0 loop
            Temp := B;
            B := A mod B;
            A := Temp;
        end loop;
        return A;
    end NWD_Iteracyjnie;

    function NWD_Rekurencyjnie(A, B : Integer) return Integer is
    begin
        if B = 0 then
            return A;
        else
            return NWD_Rekurencyjnie(B, A mod B);
        end if;
    end NWD_Rekurencyjnie;

    function Diofantyczne_Iteracyjnie(A, B, C : Integer) return Diofantyczne_Rozwiazanie is
        D : Integer := NWD_Iteracyjnie(A, B);
        Result : Diofantyczne_Rozwiazanie;
    begin
        if C mod D = 0 then
            -- Obliczanie jednego z możliwych rozwiązań
            Result.X := (C / D) * (A / D);
            Result.Y := (C / D) * (B / D);
        else
            -- Brak rozwiązania dla podanych parametrów
            Result.X := 0;
            Result.Y := 0;
        end if;
        return Result;
    end Diofantyczne_Iteracyjnie;

    function Diofantyczne_Rekurencyjnie(A, B, C : Integer) return Diofantyczne_Rozwiazanie is
        D : Integer := NWD_Rekurencyjnie(A, B);
        Result : Diofantyczne_Rozwiazanie;
    begin
        if C mod D = 0 then
            -- Obliczanie jednego z możliwych rozwiązań
            Result.X := (C / D) * (A / D);
            Result.Y := (C / D) * (B / D);
        else
            -- Brak rozwiązania dla podanych parametrów
            Result.X := 0;
            Result.Y := 0;
        end if;
        return Result;
    end Diofantyczne_Rekurencyjnie;

end Zadanie_2;

# Zadanie 3: Implementacja w języku Python

def silnia(n):
    if n < 0:
        return 0
    elif n == 0:
        return 1
    else:
        return n * silnia(n - 1)

def nwd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def diofantyczne(a, b, c):
    d = nwd(a, b)
    if c % d == 0:
        k = c // d
        return k * (a // d), k * (b // d)
    else:
        return 0, 0

// Zadanie 4: Wrapper w języku C dla modułu napisanego w Adzie

#include "zadanie_2.ads"  // Importujemy plik nagłówkowy zdefiniowany w Ada

// Funkcje opakowujące funkcje z modułu napisanego w Ada

unsigned long long silnia_wrapper(int n) {
    return Silnia(n);
}

int nwd_wrapper(int a, int b) {
    return NWD(a, b);
}

DiofantyczneRozwiazanie diofantyczne_wrapper(int a, int b, int c) {
    return Diofantyczne(a, b, c);
}

-- Zadanie 5: Wrapper w języku Ada dla biblioteki napisanej w C

with Interfaces.C_Interfaces;
use Interfaces.C_Interfaces;

package Zadanie_5 is

    function Silnia_Wrapper(N : Integer) return Unsigned_Long_Long;
    function NWD_Wrapper(A, B : Integer) return Integer;
    function Diofantyczne_Wrapper(A, B, C : Integer) return Diofantyczne_Rozwiazanie;

end Zadanie_5;

-- Zadanie_5.adb

with System; use System;

package body Zadanie_5 is

    function Silnia_Wrapper(N : Integer) return Unsigned_Long_Long is
    begin
        return Unsigned_Long_Long(biblioteka.silnia(N));
    end Silnia_Wrapper;

    function NWD_Wrapper(A, B : Integer) return Integer is
    begin
        return biblioteka.nwd(A, B);
    end NWD_Wrapper;

    function Diofantyczne_Wrapper(A, B, C : Integer) return Diofantyczne_Rozwiazanie is
    begin
        return biblioteka.diofantyczne(A, B, C);
    end Diofantyczne_Wrapper;

end Zadanie_5;

# Zadanie 6: Wrapper w języku Python dla biblioteki napisanej w C z zadania 1

from ctypes import CDLL, Structure, c_int

# Ładowanie biblioteki napisanej w C
biblioteka = CDLL("./biblioteka.so")  # Tutaj podaj ścieżkę do biblioteki .so


# Definicja struktury DiofantyczneRozwiazanie
class DiofantyczneRozwiazanie(Structure):
    _fields_ = [("x", c_int), ("y", c_int)]


# Funkcje opakowujące funkcje z biblioteki napisanej w C

def silnia(n):
    return biblioteka.silnia_iteracyjnie(n)

def nwd(a, b):
    return biblioteka.nwd_iteracyjnie(a, b)

def diofantyczne(a, b, c):
    biblioteka.diofantyczne_iteracyjnie.restype = DiofantyczneRozwiazanie
    return biblioteka.diofantyczne_iteracyjnie(a, b, c)

# Zadanie 7: Wrapper w języku Python dla biblioteki napisanej w zadaniu 3

from library import silnia, nwd, diofantyczne
# Zakładając, że library to nazwa pliku, który zawiera implementacje funkcji silnia, nwd, diofantyczne z zadania 3

